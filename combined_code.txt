=== FILE: ./jenkins/jenkins-config.yaml ===
apiVersion: v1
kind: ConfigMap
metadata:
  name: jenkins-config
  namespace: jenkins
data:
  jenkins.yaml: |
    jenkins:
      systemMessage: "Student Management System CI/CD Pipeline"
      securityRealm:
        local:
          allowsSignup: false
          users:
          - id: "admin"
            password: "admin123"
      authorizationStrategy:
        globalMatrix:
          permissions:
          - "Overall/Administer:admin"
          - "Overall/Read:authenticated"
    
    credentials:
      system:
        domainCredentials:
          - credentials:
            - usernamePassword:
                scope: SYSTEM
                id: "docker-hub"
                username: "${DOCKER_USERNAME}"
                password: "${DOCKER_PASSWORD}"
            - secretText:
                scope: SYSTEM
                id: "github-token"
                secret: "${GITHUB_TOKEN}"
    
    jobs:
      - script: >
          pipelineJob('student-app-cicd') {
            definition {
              cpsScm {
                scm {
                  git {
                    remote {
                      url('${GIT_REPO_URL}')
                      credentials('github-token')
                    }
                    branches('main')
                    scriptPath('Jenkinsfile')
                    extensions {
                      cleanBeforeCheckout()
                    }
                  }
                }
              }
            }
            properties {
              githubProjectProperty {
                projectUrlStr('${GIT_REPO_URL}')
              }
            }
            triggers {
              scm('H/5 * * * *')
              githubPush()
            }
          }

=== FILE: ./jenkins/pvc.yaml ===
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: jenkins-pvc
  namespace: jenkins
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi

=== FILE: ./jenkins/serviceaccount.yaml ===
apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins-admin
  namespace: jenkins
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: jenkins-admin
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: jenkins-admin
  namespace: jenkins

=== FILE: ./jenkins/service.yaml ===
apiVersion: v1
kind: Service
metadata:
  name: jenkins
  namespace: jenkins
spec:
  selector:
    app: jenkins
  ports:
  - port: 8080
    targetPort: 8080
    nodePort: 32000
  type: NodePort

=== FILE: ./jenkins/namespace.yaml ===
apiVersion: v1
kind: Namespace
metadata:
  name: jenkins

=== FILE: ./jenkins/kube-config.yaml ===
apiVersion: v1
kind: ConfigMap
metadata:
  name: kube-config
  namespace: jenkins
data:
  config: |
    apiVersion: v1
    kind: Config
    clusters:
    - cluster:
        server: https://student-app-control-plane:6443
        certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUN... # KIND CA cert
      name: kind-student-app
    contexts:
    - context:
        cluster: kind-student-app
        user: kind-student-app
      name: kind-student-app
    current-context: kind-student-app
    preferences: {}
    users:
    - name: kind-student-app
      user:
        client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUN... # KIND client cert
        client-key-data: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlF... # KIND client key

=== FILE: ./jenkins/deployment.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jenkins
  namespace: jenkins
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jenkins
  template:
    metadata:
      labels:
        app: jenkins
    spec:
      serviceAccountName: jenkins-admin
      containers:
      - name: jenkins
        image: jenkins/jenkins:lts-jdk17
        ports:
        - containerPort: 8080
        - containerPort: 50000
        volumeMounts:
        - name: jenkins-home
          mountPath: /var/jenkins_home
        - name: docker-sock
          mountPath: /var/run/docker.sock
        - name: kube-config
          mountPath: /home/jenkins/.kube
        env:
        - name: JAVA_OPTS
          value: "-Djenkins.install.runSetupWizard=false"
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1"
      volumes:
      - name: jenkins-home
        persistentVolumeClaim:
          claimName: jenkins-pvc
      - name: docker-sock
        hostPath:
          path: /var/run/docker.sock
      - name: kube-config
        configMap:
          name: kube-config

=== FILE: ./test-app.sh ===
#!/bin/bash
echo "üß™ Testing Student Management App..."
echo "===================================="

cd ~/student-app-k8s-jenkins-cicd

echo "1. Testing backend..."
cd app/backend
node -c app.js && echo "‚úÖ Backend app.js syntax OK" || echo "‚ùå Backend app.js syntax error"
cd ../..

echo "2. Testing frontend..."
cd app/frontend
if [ -f "index.html" ]; then
    echo "‚úÖ index.html exists"
else
    echo "‚ùå index.html missing"
fi
if [ -f "app.js" ]; then
    echo "‚úÖ app.js exists"
else
    echo "‚ùå app.js missing"
fi
if [ -f "styles.css" ]; then
    echo "‚úÖ styles.css exists"
else
    echo "‚ùå styles.css missing"
fi
cd ../..

echo "3. Testing Docker builds..."
echo "Building backend..."
docker build -t student-backend-test app/backend/ && echo "‚úÖ Backend Docker build OK" || echo "‚ùå Backend Docker build failed"

echo "Building frontend..."
docker build -t student-frontend-test app/frontend/ && echo "‚úÖ Frontend Docker build OK" || echo "‚ùå Frontend Docker build failed"

echo ""
echo "‚úÖ Testing complete!"
echo "Run ./scripts/deploy.sh to deploy to KIND"

=== FILE: ./guaranteed-deploy.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: student-backend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: student-app
spec:
  type: NodePort
  selector:
    app: backend
  ports:
  - port: 3000
    targetPort: 3000
    nodePort: 30001
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: student-frontend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: student-app
spec:
  type: NodePort
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
    nodePort: 31349


=== FILE: ./restore-original-ui.sh ===
#!/bin/bash
echo "üé® RESTORING ORIGINAL UI WITH CRUD"
echo "==================================="

cd ~/student-app-k8s-jenkins-cicd

echo "1. Rebuilding frontend with original UI..."
cd app/frontend

# Create the three files from above if they don't exist
# (Copy the HTML, CSS, and JS code from above into these files)

cd ../..

echo "2. Building Docker image..."
docker build -t student-frontend-original:latest app/frontend/

echo "3. Loading to KIND..."
kind load docker-image student-frontend-original:latest --name student-app

echo "4. Updating deployment..."
kubectl rollout

=== FILE: ./combine_code.sh ===
#!/bin/bash
# combine_code.sh - Combine all code files into one organized file

# Configuration
OUTPUT_FILE="combined_code_$(date +%Y%m%d_%H%M%S).txt"

# File extensions to include (case insensitive patterns)
FILE_PATTERNS=(
    "*.js"
    "*.yaml"
    "*.yml"
    "*.sh"
    "Dockerfile"
    "Dockerfile.*"
    "Jenkinsfile"
    "Jenkinsfile.*"
    "docker-compose*.yml"
    "docker-compose*.yaml"
)

# Directories to exclude
EXCLUDE_DIRS=(
    "node_modules"
    ".git"
    "dist"
    "build"
    ".next"
    "target"
    "vendor"
    "__pycache__"
    "venv"
    ".idea"
    ".vscode"
)

echo "=== Code Collection Started ==="
echo "Output file: $OUTPUT_FILE"

# Clear or create output file
> "$OUTPUT_FILE"

# Write header
{
    echo "# CODE REPOSITORY COLLECTION"
    echo "# Generated: $(date)"
    echo "# Project: $(basename "$PWD")"
    echo "=========================================="
    echo ""
} >> "$OUTPUT_FILE"

# Build find command
find_cmd="find . -type f "

# Add exclude patterns
for dir in "${EXCLUDE_DIRS[@]}"; do
    find_cmd+="-not -path \"./$dir/*\" -not -path \"./$dir\" "
done

# Add file patterns
find_cmd+="\( "
first=true
for pattern in "${FILE_PATTERNS[@]}"; do
    if [ "$first" = true ]; then
        find_cmd+="-name \"$pattern\""
        first=false
    else
        find_cmd+=" -o -name \"$pattern\""
    fi
done
find_cmd+=" \)"

# Execute find and process files
echo "Searching for files..."
file_count=0
total_size=0

eval "$find_cmd" | sort | while read -r file; do
    # Skip empty files
    if [ ! -s "$file" ]; then
        continue
    fi
    
    # Get file info
    file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
    rel_path="${file#./}"
    
    echo "Processing: $rel_path (${file_size} bytes)"
    
    # Write file header
    {
        echo ""
        echo "################################################################"
        echo "# FILE: $rel_path"
        echo "# SIZE: ${file_size} bytes"
        echo "# TYPE: $(file -b --mime-type "$file" 2>/dev/null || echo "unknown")"
        echo "################################################################"
        echo ""
    } >> "$OUTPUT_FILE"
    
    # Add file content
    cat "$file" >> "$OUTPUT_FILE"
    
    # Ensure newline at end of file content
    echo "" >> "$OUTPUT_FILE"
    
    # Update counters
    ((file_count++))
    total_size=$((total_size + file_size))
done

# Write summary
{
    echo ""
    echo "=========================================="
    echo "# SUMMARY"
    echo "# Files processed: $file_count"
    echo "# Total size: $total_size bytes"
    echo "# Output file: $OUTPUT_FILE"
    echo "# Generation completed: $(date)"
} >> "$OUTPUT_FILE"

echo ""
echo "=== Code Collection Completed ==="
echo "Total files processed: $file_count"
echo "Output saved to: $OUTPUT_FILE"
echo "File size: $(du -h "$OUTPUT_FILE" | cut -f1)"

=== FILE: ./fix-now.sh ===
#!/bin/bash
echo "üîß Fixing Access Now!"
echo "===================="

# Clean up
pkill -f "kubectl port-forward" 2>/dev/null

# Use simple port-forward
kubectl port-forward -n student-app service/backend-service 30001:3000 &
sleep 2
kubectl port-forward -n student-app service/frontend-service 8888:80 &
sleep 2

# Test
echo "Testing backend..."
if curl -s http://localhost:30001/api/health > /dev/null; then
    echo "‚úÖ Backend is working!"
    echo "Backend response:"
    curl -s http://localhost:30001/api/health | python3 -m json.tool 2>/dev/null || curl -s http://localhost:30001/api/health
else
    echo "‚ùå Backend not responding"
    echo "Checking pods..."
    kubectl get pods -n student-app
    echo "Checking logs..."
    kubectl logs -n student-app deployment/backend --tail=10
fi

echo ""
echo "üåê Access URLs:"
echo "Frontend: http://localhost:8888"
echo "Backend API: http://localhost:30001/api/health"
echo ""
echo "‚èπÔ∏è  To stop: Ctrl+C or run: pkill -f 'kubectl port-forward'"


=== FILE: ./diagnose.sh ===
#!/bin/bash
echo "üîç DIAGNOSTIC - Why No Data?"
echo "============================="

echo "1. Are pods running?"
kubectl get pods -n student-app -o wide

echo ""
echo "2. Is backend responding?"
curl -v http://localhost:30001/api/health 2>&1 | head -20

echo ""
echo "3. Backend logs:"
kubectl logs -n student-app deployment/backend --tail=10

echo ""
echo "4. Frontend logs:"
kubectl logs -n student-app deployment/frontend --tail=10

echo ""
echo "5. Check browser console:"
echo "   - Open http://localhost:8888"
echo "   - Press F12"
echo "   - Go to Console tab"
echo "   - Look for errors or 'API_URL' log"

echo ""
echo "6. Direct API test:"
echo "   curl http://localhost:30001/api/students"

echo ""
echo "‚úÖ Diagnostic complete"


=== FILE: ./simple-backend.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: student-backend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
        env:
        - name: PORT
          value: "3000"
        - name: NODE_ENV
          value: "production"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: student-app
spec:
  type: NodePort
  selector:
    app: backend
  ports:
  - port: 3000
    targetPort: 3000
    nodePort: 30001


=== FILE: ./app/backend-fresh/app.js ===
const express = require('express');
const cors = require('cors');
const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Sample data
let students = [
    { id: 1, name: 'John Doe', age: 20, grade: 'A', email: 'john@school.com' },
    { id: 2, name: 'Jane Smith', age: 21, grade: 'B', email: 'jane@school.com' },
    { id: 3, name: 'Mike Johnson', age: 19, grade: 'A', email: 'mike@school.com' },
    { id: 4, name: 'Sarah Wilson', age: 22, grade: 'C', email: 'sarah@school.com' },
    { id: 5, name: 'Tom Brown', age: 18, grade: 'B', email: 'tom@school.com' }
];

// Health endpoint
app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'OK', 
        message: 'Backend is working!',
        students: students.length 
    });
});

// Get all students
app.get('/api/students', (req, res) => {
    res.json(students);
});

// Start server
app.listen(PORT, '0.0.0.0', () => {
    console.log(`‚úÖ Server running on port ${PORT}`);
    console.log(`‚úÖ Health: http://localhost:${PORT}/api/health`);
    console.log(`‚úÖ Students: http://localhost:${PORT}/api/students`);
});


=== FILE: ./app/backend-fresh/Dockerfile ===
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["node", "app.js"]


=== FILE: ./app/frontend/config.js ===
// This file will be populated by Docker entrypoint


=== FILE: ./app/frontend/backup/app.js ===
console.log("GUARANTEED Frontend loaded");


=== FILE: ./app/frontend/app.js ===
// API Base URL - use localhost for KIND port-forward
const API_BASE_URL = 'http://localhost:30001/api';

console.log('üöÄ Student Management System Frontend');
console.log('üåê API Base URL:', API_BASE_URL);

// DOM Elements
const studentTableBody = document.getElementById('student-table-body');
const studentModal = document.getElementById('student-modal');
const confirmModal = document.getElementById('confirm-modal');
const studentForm = document.getElementById('student-form');
const searchInput = document.getElementById('search-input');
const addStudentBtn = document.getElementById('add-student-btn');
const closeModalBtn = document.getElementById('close-modal');
const cancelBtn = document.getElementById('cancel-btn');
const closeConfirmModalBtn = document.getElementById('close-confirm-modal');
const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
const toast = document.getElementById('toast');
const loadingElement = document.getElementById('loading');
const k8sStatus = document.getElementById('k8s-status');

// Summary elements
const totalStudentsEl = document.getElementById('total-students');
const gradeAStudentsEl = document.getElementById('grade-a');
const avgAgeEl = document.getElementById('avg-age');

// State variables
let students = [];
let currentStudentId = null;
let isEditing = false;

// Initialize the application
async function init() {
    console.log('üöÄ Initializing Student Management System...');
    console.log('üåê API Base URL:', API_BASE_URL);
    
    setupEventListeners();
    await checkBackendConnection();
    await loadStudents();
}

// Check backend connection
async function checkBackendConnection() {
    try {
        const response = await fetch(`${API_BASE_URL}/health`);
        
        if (response.ok) {
            k8sStatus.textContent = 'K8s: Online';
            k8sStatus.className = 'k8s-status';
            return true;
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
    } catch (error) {
        console.error('‚ùå Backend connection failed:', error);
        k8sStatus.textContent = 'K8s: Offline';
        k8sStatus.className = 'k8s-status offline';
        return false;
    }
}

// Set up event listeners
function setupEventListeners() {
    addStudentBtn.addEventListener('click', openAddModal);
    closeModalBtn.addEventListener('click', closeModal);
    cancelBtn.addEventListener('click', closeModal);
    closeConfirmModalBtn.addEventListener('click', closeConfirmModal);
    cancelDeleteBtn.addEventListener('click', closeConfirmModal);
    studentForm.addEventListener('submit', saveStudent);
    searchInput.addEventListener('input', filterStudents);
    confirmDeleteBtn.addEventListener('click', deleteStudent);
    
    console.log('‚úÖ Event listeners set up');
}

// Load students from API
async function loadStudents() {
    showLoading(true);
    try {
        console.log('üì° Loading students from:', `${API_BASE_URL}/students`);
        const response = await fetch(`${API_BASE_URL}/students`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        students = await response.json();
        console.log('‚úÖ Loaded students:', students);
        renderStudentTable();
        updateSummary();
    } catch (error) {
        console.error('‚ùå Error loading students:', error);
        showToast('Error loading students: ' + error.message, true);
        students = [];
        renderStudentTable();
        updateSummary();
    } finally {
        showLoading(false);
    }
}

// Show/hide loading indicator
function showLoading(show) {
    if (show) {
        loadingElement.classList.add('show');
        studentTableBody.innerHTML = '';
    } else {
        loadingElement.classList.remove('show');
    }
}

// Render student table
function renderStudentTable(studentsToRender = students) {
    studentTableBody.innerHTML = '';
    
    if (studentsToRender.length === 0) {
        studentTableBody.innerHTML = `
            <tr>
                <td colspan="6" style="text-align: center; color: #666; padding: 20px;">
                    No students found. <br>
                    <small>Try adding a student or check if the backend is running.</small>
                </td>
            </tr>
        `;
        return;
    }
    
    studentsToRender.forEach(student => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${student.id}</td>
            <td>${student.name}</td>
            <td>${student.age}</td>
            <td><span class="grade-badge grade-${student.grade}">${student.grade}</span></td>
            <td>${student.email}</td>
            <td>
                <div class="action-btns">
                    <button class="action-btn edit-btn" data-id="${student.id}">Edit</button>
                    <button class="action-btn delete-btn" data-id="${student.id}">Delete</button>
                </div>
            </td>
        `;
        studentTableBody.appendChild(row);
    });
    
    // Add event listeners to action buttons
    document.querySelectorAll('.edit-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const id = parseInt(e.target.getAttribute('data-id'));
            openEditModal(id);
        });
    });
    
    document.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const id = parseInt(e.target.getAttribute('data-id'));
            openConfirmModal(id);
        });
    });
}

// Update summary cards
function updateSummary() {
    const totalStudents = students.length;
    const gradeAStudents = students.filter(student => student.grade === 'A').length;
    const totalAge = students.reduce((sum, student) => sum + student.age, 0);
    const avgAge = students.length > 0 ? Math.round(totalAge / students.length) : 0;
    
    document.getElementById('total-students').textContent = totalStudents;
    document.getElementById('grade-a').textContent = gradeAStudents;
    document.getElementById('avg-age').textContent = avgAge;
}

// Filter students based on search input
function filterStudents() {
    const searchTerm = searchInput.value.toLowerCase();
    const filteredStudents = students.filter(student => 
        student.name.toLowerCase().includes(searchTerm) ||
        student.email.toLowerCase().includes(searchTerm) ||
        student.grade.toLowerCase().includes(searchTerm)
    );
    renderStudentTable(filteredStudents);
}

// Open modal for adding a new student
function openAddModal() {
    isEditing = false;
    document.getElementById('modal-title').textContent = 'Add New Student';
    studentForm.reset();
    document.getElementById('student-id').value = '';
    studentModal.classList.add('show');
}

// Open modal for editing a student
function openEditModal(id) {
    isEditing = true;
    const student = students.find(s => s.id === id);
    if (student) {
        document.getElementById('modal-title').textContent = 'Edit Student';
        document.getElementById('student-id').value = student.id;
        document.getElementById('name').value = student.name;
        document.getElementById('age').value = student.age;
        document.getElementById('grade').value = student.grade;
        document.getElementById('email').value = student.email;
        studentModal.classList.add('show');
    }
}

// Close the student modal
function closeModal() {
    studentModal.classList.remove('show');
}

// Open confirmation modal for deletion
function openConfirmModal(id) {
    currentStudentId = id;
    const student = students.find(s => s.id === id);
    if (student) {
        document.querySelector('#confirm-modal p').textContent = 
            `Are you sure you want to delete "${student.name}"? This action cannot be undone.`;
    }
    confirmModal.classList.add('show');
}

// Close confirmation modal
function closeConfirmModal() {
    confirmModal.classList.remove('show');
    currentStudentId = null;
}

// Save student (both add and edit)
async function saveStudent(e) {
    e.preventDefault();
    
    const studentData = {
        name: document.getElementById('name').value.trim(),
        age: parseInt(document.getElementById('age').value),
        grade: document.getElementById('grade').value,
        email: document.getElementById('email').value.trim()
    };
    
    // Validation
    if (!studentData.name || !studentData.age || !studentData.grade || !studentData.email) {
        showToast('Please fill in all fields', true);
        return;
    }
    
    if (studentData.age < 16 || studentData.age > 30) {
        showToast('Age must be between 16 and 30', true);
        return;
    }
    
    if (!studentData.email.includes('@')) {
        showToast('Please enter a valid email address', true);
        return;
    }
    
    try {
        let response;
        if (isEditing) {
            const studentId = document.getElementById('student-id').value;
            console.log('üîÑ Updating student:', studentId, studentData);
            response = await fetch(`${API_BASE_URL}/students/${studentId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(studentData)
            });
        } else {
            console.log('‚ûï Creating student:', studentData);
            response = await fetch(`${API_BASE_URL}/students`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(studentData)
            });
        }
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `HTTP ${response.status}`);
        }
        
        const result = await response.json();
        showToast(result.message || 'Student saved successfully!');
        
        // Reload students to get the updated list
        await loadStudents();
        closeModal();
    } catch (error) {
        console.error('‚ùå Error saving student:', error);
        showToast('Error: ' + error.message, true);
    }
}

// Delete student
async function deleteStudent() {
    try {
        console.log('üóëÔ∏è Deleting student:', currentStudentId);
        const response = await fetch(`${API_BASE_URL}/students/${currentStudentId}`, {
            method: 'DELETE'
        });
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `HTTP ${response.status}`);
        }
        
        const result = await response.json();
        showToast(result.message || 'Student deleted successfully!');
        
        // Reload students to get the updated list
        await loadStudents();
        closeConfirmModal();
    } catch (error) {
        console.error('‚ùå Error deleting student:', error);
        showToast('Error: ' + error.message, true);
    }
}

// Show toast notification
function showToast(message, isError = false) {
    toast.textContent = message;
    toast.className = 'toast' + (isError ? ' error' : '');
    toast.classList.add('show');
    
    setTimeout(() => {
        toast.classList.remove('show');
    }, 4000);
}

// Initialize the application when DOM is loaded
document.addEventListener('DOMContentLoaded', async () => {
    console.log('üéØ Student Management System Starting...');
    await init();
});


=== FILE: ./app/frontend/app-fixed.js ===
// Configuration - ALWAYS use localhost for port-forward
const API_BASE_URL = 'http://localhost:30001/api';

console.log('üéØ Student Management Frontend - FIXED VERSION');
console.log('üåê Using API:', API_BASE_URL);

// DOM Elements
const studentTableBody = document.getElementById('student-table-body');
const loadingElement = document.getElementById('loading');
const totalStudentsEl = document.getElementById('total-students');
const gradeAStudentsEl = document.getElementById('grade-a');
const avgAgeEl = document.getElementById('avg-age');

// Demo data as fallback
const DEMO_STUDENTS = [
    { id: 1, name: 'Demo Student 1', age: 20, grade: 'A', email: 'demo1@school.com' },
    { id: 2, name: 'Demo Student 2', age: 21, grade: 'B', email: 'demo2@school.com' },
    { id: 3, name: 'Demo Student 3', age: 22, grade: 'A', email: 'demo3@school.com' }
];

// Initialize
async function init() {
    console.log('Initializing app...');
    showLoading(true);
    
    // Try to load from API
    const apiStudents = await loadFromAPI();
    
    if (apiStudents.length > 0) {
        console.log('Using API data:', apiStudents.length, 'students');
        displayStudents(apiStudents);
    } else {
        console.log('Using demo data');
        displayStudents(DEMO_STUDENTS);
        showMessage('‚ö†Ô∏è Using demo data (backend not connected)', 'warning');
    }
    
    showLoading(false);
}

// Load from API
async function loadFromAPI() {
    try {
        console.log('Fetching from:', API_BASE_URL + '/students');
        const response = await fetch(API_BASE_URL + '/students', {
            timeout: 5000
        });
        
        if (response.ok) {
            return await response.json();
        }
    } catch (error) {
        console.log('API fetch failed:', error.message);
    }
    return [];
}

// Display students in table
function displayStudents(students) {
    studentTableBody.innerHTML = '';
    
    if (students.length === 0) {
        studentTableBody.innerHTML = `
            <tr>
                <td colspan="6" style="text-align: center; padding: 20px; color: #666;">
                    No students to display
                </td>
            </tr>
        `;
        return;
    }
    
    students.forEach(student => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${student.id}</td>
            <td>${student.name}</td>
            <td>${student.age}</td>
            <td><span class="grade-badge grade-${student.grade}">${student.grade}</span></td>
            <td>${student.email}</td>
            <td>
                <div class="action-btns">
                    <button class="action-btn edit-btn">Edit</button>
                    <button class="action-btn delete-btn">Delete</button>
                </div>
            </td>
        `;
        studentTableBody.appendChild(row);
    });
    
    // Update summary
    updateSummary(students);
}

// Update summary cards
function updateSummary(students) {
    const total = students.length;
    const gradeA = students.filter(s => s.grade === 'A').length;
    const totalAge = students.reduce((sum, s) => sum + s.age, 0);
    const avgAge = total > 0 ? Math.round(totalAge / total) : 0;
    
    totalStudentsEl.textContent = total;
    gradeAStudentsEl.textContent = gradeA;
    avgAgeEl.textContent = avgAge;
}

// Show/hide loading
function showLoading(show) {
    if (show) {
        loadingElement.classList.add('show');
    } else {
        loadingElement.classList.remove('show');
    }
}

// Show message
function showMessage(text, type = 'info') {
    const message = document.createElement('div');
    message.className = `message ${type}`;
    message.textContent = text;
    message.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 10px 20px;
        background: ${type === 'warning' ? '#ff9800' : '#4CAF50'};
        color: white;
        border-radius: 5px;
        z-index: 1000;
    `;
    document.body.appendChild(message);
    setTimeout(() => message.remove(), 5000);
}

// Add fetch timeout
if (!window.fetch.timeout) {
    window.fetch.timeout = function(ms) {
        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => reject(new Error('Timeout')), ms);
            fetch.then(response => {
                clearTimeout(timer);
                resolve(response);
            }).catch(reject);
        });
    };
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', init);


=== FILE: ./app/frontend/Dockerfile ===
FROM nginx:alpine

# Copy all frontend files
COPY . /usr/share/nginx/html/

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]


=== FILE: ./app/backend/app-simple.js ===
const express = require('express');
const cors = require('cors');
const app = express();
const PORT = 3000;

console.log('üöÄ SIMPLE Backend Starting...');

app.use(cors());
app.use(express.json());

const students = [
    { id: 1, name: 'Alice Johnson', age: 20, grade: 'A', email: 'alice@school.com' },
    { id: 2, name: 'Bob Smith', age: 21, grade: 'B', email: 'bob@school.com' },
    { id: 3, name: 'Charlie Brown', age: 22, grade: 'A', email: 'charlie@school.com' }
];

app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'OK', 
        message: 'SIMPLE Backend is working!',
        students: students.length 
    });
});

app.get('/api/students', (req, res) => {
    console.log('GET /api/students - returning', students.length, 'students');
    res.json(students);
});

app.listen(PORT, '0.0.0.0', () => {
    console.log(`‚úÖ SIMPLE Backend on port ${PORT}`);
});


=== FILE: ./app/backend/app.js ===
const express = require('express');
const cors = require('cors');
const app = express();
const PORT = 3000;

console.log('üöÄ Student Backend with FULL CRUD Starting...');

app.use(cors());
app.use(express.json());

// In-memory storage
let students = [
    { id: 1, name: 'John Doe', age: 20, grade: 'A', email: 'john@school.com' },
    { id: 2, name: 'Jane Smith', age: 21, grade: 'B', email: 'jane@school.com' },
    { id: 3, name: 'Mike Johnson', age: 19, grade: 'A', email: 'mike@school.com' },
    { id: 4, name: 'Sarah Wilson', age: 22, grade: 'C', email: 'sarah@school.com' },
    { id: 5, name: 'Tom Brown', age: 18, grade: 'B', email: 'tom@school.com' }
];

let nextId = 6;

// 1. Health check
app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'OK', 
        message: 'Backend with FULL CRUD is working!',
        timestamp: new Date().toISOString(),
        studentCount: students.length
    });
});

// 2. GET all students
app.get('/api/students', (req, res) => {
    console.log('GET /api/students - returning', students.length, 'students');
    res.json(students);
});

// 3. GET single student by ID
app.get('/api/students/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const student = students.find(s => s.id === id);
    
    if (!student) {
        return res.status(404).json({ error: 'Student not found' });
    }
    
    res.json(student);
});

// 4. POST create new student (FRONTEND USES THIS)
app.post('/api/students', (req, res) => {
    const { name, age, grade, email } = req.body;
    
    // Validation
    if (!name || !age || !grade || !email) {
        return res.status(400).json({ error: 'All fields are required' });
    }
    
    const newStudent = {
        id: nextId++,
        name: name.trim(),
        age: parseInt(age),
        grade: grade.toUpperCase(),
        email: email.trim()
    };
    
    students.push(newStudent);
    console.log('POST /api/students - created:', newStudent);
    
    res.status(201).json({
        message: 'Student created successfully',
        student: newStudent
    });
});

// 5. PUT update student (FRONTEND USES THIS)
app.put('/api/students/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const { name, age, grade, email } = req.body;
    
    // Validation
    if (!name || !age || !grade || !email) {
        return res.status(400).json({ error: 'All fields are required' });
    }
    
    const studentIndex = students.findIndex(s => s.id === id);
    if (studentIndex === -1) {
        return res.status(404).json({ error: 'Student not found' });
    }
    
    const updatedStudent = {
        id,
        name: name.trim(),
        age: parseInt(age),
        grade: grade.toUpperCase(),
        email: email.trim()
    };
    
    students[studentIndex] = updatedStudent;
    console.log('PUT /api/students/' + id + ' - updated:', updatedStudent);
    
    res.json({
        message: 'Student updated successfully',
        student: updatedStudent
    });
});

// 6. DELETE student (FRONTEND USES THIS)
app.delete('/api/students/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const studentIndex = students.findIndex(s => s.id === id);
    
    if (studentIndex === -1) {
        return res.status(404).json({ error: 'Student not found' });
    }
    
    const deletedStudent = students.splice(studentIndex, 1)[0];
    console.log('DELETE /api/students/' + id + ' - deleted:', deletedStudent);
    
    res.json({
        message: 'Student deleted successfully',
        student: deletedStudent
    });
});

// 7. Search students
app.get('/api/students/search/:query', (req, res) => {
    const query = req.params.query.toLowerCase();
    const results = students.filter(s => 
        s.name.toLowerCase().includes(query) ||
        s.email.toLowerCase().includes(query) ||
        s.grade.toLowerCase().includes(query)
    );
    res.json(results);
});

// 8. 404 handler for undefined routes
app.use((req, res) => {
    console.log('404 for:', req.method, req.path);
    res.status(404).json({ 
        error: 'Endpoint not found',
        message: `Route ${req.method} ${req.path} does not exist`
    });
});

// Start server
app.listen(PORT, '0.0.0.0', () => {
    console.log(`‚úÖ Backend with FULL CRUD running on port ${PORT}`);
    console.log(`‚úÖ Available endpoints:`);
    console.log(`   GET    /api/health`);
    console.log(`   GET    /api/students`);
    console.log(`   GET    /api/students/:id`);
    console.log(`   POST   /api/students`);
    console.log(`   PUT    /api/students/:id`);
    console.log(`   DELETE /api/students/:id`);
    console.log(`   GET    /api/students/search/:query`);
    console.log(`‚úÖ Total students loaded: ${students.length}`);
});


=== FILE: ./app/backend/app-guaranteed.js ===
console.log("üöÄ GUARANTEED BACKEND STARTING");
const express = require("express");
const cors = require("cors");
const app = express();
app.use(cors());
app.use(express.json());

const students = [
    {id:1,name:"GUARANTEED Student 1",age:20,grade:"A",email:"student1@school.com"},
    {id:2,name:"GUARANTEED Student 2",age:21,grade:"B",email:"student2@school.com"},
    {id:3,name:"GUARANTEED Student 3",age:22,grade:"A",email:"student3@school.com"},
    {id:4,name:"GUARANTEED Student 4",age:23,grade:"C",email:"student4@school.com"},
    {id:5,name:"GUARANTEED Student 5",age:19,grade:"B",email:"student5@school.com"}
];

app.get("/api/health", (req, res) => {
    console.log("Health check");
    res.json({status:"OK",message:"GUARANTEED Backend",students:students.length});
});

app.get("/api/students", (req, res) => {
    console.log("Returning", students.length, "students");
    res.json(students);
});

app.listen(3000, "0.0.0.0", () => {
    console.log("‚úÖ GUARANTEED Backend running on 3000");
});


=== FILE: ./app/backend/Dockerfile ===
FROM node:18-alpine

WORKDIR /app

# Copy package files first
COPY package*.json ./

# Install dependencies
RUN npm install --production --no-optional && npm cache clean --force

# Copy source code
COPY . .

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001 && \
    chown -R nodejs:nodejs /app

USER nodejs

EXPOSE 3000

CMD ["node", "app.js"]

=== FILE: ./app/backend/app-complete.js ===
const express = require('express');
const cors = require('cors');
const app = express();
const PORT = 3000;

console.log('üöÄ Student Backend with FULL CRUD Starting...');

app.use(cors());
app.use(express.json());

// In-memory storage
let students = [
    { id: 1, name: 'John Doe', age: 20, grade: 'A', email: 'john@school.com' },
    { id: 2, name: 'Jane Smith', age: 21, grade: 'B', email: 'jane@school.com' },
    { id: 3, name: 'Mike Johnson', age: 19, grade: 'A', email: 'mike@school.com' },
    { id: 4, name: 'Sarah Wilson', age: 22, grade: 'C', email: 'sarah@school.com' },
    { id: 5, name: 'Tom Brown', age: 18, grade: 'B', email: 'tom@school.com' }
];

let nextId = 6;

// 1. Health check
app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'OK', 
        message: 'Backend with FULL CRUD is working!',
        timestamp: new Date().toISOString(),
        studentCount: students.length
    });
});

// 2. GET all students
app.get('/api/students', (req, res) => {
    console.log('GET /api/students - returning', students.length, 'students');
    res.json(students);
});

// 3. GET single student by ID
app.get('/api/students/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const student = students.find(s => s.id === id);
    
    if (!student) {
        return res.status(404).json({ error: 'Student not found' });
    }
    
    res.json(student);
});

// 4. POST create new student (FRONTEND USES THIS)
app.post('/api/students', (req, res) => {
    const { name, age, grade, email } = req.body;
    
    // Validation
    if (!name || !age || !grade || !email) {
        return res.status(400).json({ error: 'All fields are required' });
    }
    
    const newStudent = {
        id: nextId++,
        name: name.trim(),
        age: parseInt(age),
        grade: grade.toUpperCase(),
        email: email.trim()
    };
    
    students.push(newStudent);
    console.log('POST /api/students - created:', newStudent);
    
    res.status(201).json({
        message: 'Student created successfully',
        student: newStudent
    });
});

// 5. PUT update student (FRONTEND USES THIS)
app.put('/api/students/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const { name, age, grade, email } = req.body;
    
    // Validation
    if (!name || !age || !grade || !email) {
        return res.status(400).json({ error: 'All fields are required' });
    }
    
    const studentIndex = students.findIndex(s => s.id === id);
    if (studentIndex === -1) {
        return res.status(404).json({ error: 'Student not found' });
    }
    
    const updatedStudent = {
        id,
        name: name.trim(),
        age: parseInt(age),
        grade: grade.toUpperCase(),
        email: email.trim()
    };
    
    students[studentIndex] = updatedStudent;
    console.log('PUT /api/students/' + id + ' - updated:', updatedStudent);
    
    res.json({
        message: 'Student updated successfully',
        student: updatedStudent
    });
});

// 6. DELETE student (FRONTEND USES THIS)
app.delete('/api/students/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const studentIndex = students.findIndex(s => s.id === id);
    
    if (studentIndex === -1) {
        return res.status(404).json({ error: 'Student not found' });
    }
    
    const deletedStudent = students.splice(studentIndex, 1)[0];
    console.log('DELETE /api/students/' + id + ' - deleted:', deletedStudent);
    
    res.json({
        message: 'Student deleted successfully',
        student: deletedStudent
    });
});

// 7. Search students
app.get('/api/students/search/:query', (req, res) => {
    const query = req.params.query.toLowerCase();
    const results = students.filter(s => 
        s.name.toLowerCase().includes(query) ||
        s.email.toLowerCase().includes(query) ||
        s.grade.toLowerCase().includes(query)
    );
    res.json(results);
});

// 8. 404 handler for undefined routes
app.use((req, res) => {
    console.log('404 for:', req.method, req.path);
    res.status(404).json({ 
        error: 'Endpoint not found',
        message: `Route ${req.method} ${req.path} does not exist`
    });
});

// Start server
app.listen(PORT, '0.0.0.0', () => {
    console.log(`‚úÖ Backend with FULL CRUD running on port ${PORT}`);
    console.log(`‚úÖ Available endpoints:`);
    console.log(`   GET    /api/health`);
    console.log(`   GET    /api/students`);
    console.log(`   GET    /api/students/:id`);
    console.log(`   POST   /api/students`);
    console.log(`   PUT    /api/students/:id`);
    console.log(`   DELETE /api/students/:id`);
    console.log(`   GET    /api/students/search/:query`);
    console.log(`‚úÖ Total students loaded: ${students.length}`);
});


=== FILE: ./scripts/setup-jenkins.sh ===
#!/bin/bash
echo "üöÄ Setting up Jenkins CI/CD for Student Management App..."

# Create Jenkins namespace and resources
kubectl apply -f jenkins/namespace.yaml

# Create service account and permissions
kubectl apply -f jenkins/serviceaccount.yaml

# Create config maps
kubectl apply -f jenkins/kube-config.yaml
kubectl apply -f jenkins/jenkins-config.yaml

# Create PVC
kubectl apply -f jenkins/pvc.yaml

# Deploy Jenkins
kubectl apply -f jenkins/deployment.yaml
kubectl apply -f jenkins/service.yaml

# Wait for Jenkins to be ready
echo "‚è≥ Waiting for Jenkins to start..."
sleep 30
kubectl wait --for=condition=ready pod -l app=jenkins -n jenkins --timeout=300s

# Get Jenkins admin password
echo ""
echo "üìã Jenkins Admin Credentials:"
echo "Username: admin"
echo "Password: admin123"
echo ""
echo "üåê Access Jenkins at: http://$(minikube ip):32000"
echo ""
echo "üéØ Jenkins setup completed!"

=== FILE: ./scripts/access-app.sh ===
#!/bin/bash
echo "üéì Student Management App - Access Guide"
echo "========================================"
echo "Using KIND Kubernetes Cluster"
echo "============================="

# Check if KIND cluster exists
if ! kind get clusters | grep -q "student-app"; then
    echo "‚ùå KIND cluster 'student-app' not found!"
    echo "   Run: ./scripts/kind-setup.sh"
    exit 1
fi

# Set kubectl context
kubectl config use-context kind-student-app

# Kill any existing port-forwards (not needed with KIND port mappings, but just in case)
pkill -f "kubectl port-forward" 2>/dev/null || true

echo ""
echo "‚úÖ Application is accessible via KIND port mappings!"
echo ""
echo "üåê ACCESS URLs:"
echo "   Frontend (UI):    http://localhost:31349"
echo "   Backend (API):    http://localhost:30001/api"
echo ""
echo "üîç TEST ENDPOINTS:"
echo "   Health Check:     curl http://localhost:30001/api/health"
echo "   List Students:    curl http://localhost:30001/api/students"
echo ""
echo "üìä DEMO DATA:"
echo "   The app comes with 5 sample students"
echo "   You can add, edit, and delete students"
echo ""
echo "üîÑ If you need to restart:"
echo "   ./scripts/teardown.sh"
echo "   ./scripts/deploy.sh"
echo ""
echo "üîß Troubleshooting:"
echo "   Check pod status: kubectl get pods -n student-app"
echo "   View logs: kubectl logs -n student-app deployment/backend"
echo ""
echo "üéØ Happy Learning with KIND Kubernetes!"

=== FILE: ./scripts/teardown.sh ===
#!/bin/bash
echo "üßπ Cleaning up Student Management App from KIND cluster..."

# Set kubectl context
kubectl config use-context kind-student-app 2>/dev/null || true

# Delete all resources
kubectl delete -f k8s/frontend/ --ignore-not-found=true
kubectl delete -f k8s/backend/ --ignore-not-found=true
kubectl delete -f k8s/mysql/ --ignore-not-found=true
kubectl delete -f k8s/configmap.yaml --ignore-not-found=true
kubectl delete -f k8s/secrets.yaml --ignore-not-found=true
kubectl delete -f k8s/namespace.yaml --ignore-not-found=true

# Kill any port-forward processes
pkill -f "kubectl port-forward" 2>/dev/null || true

echo "‚úÖ Cleanup completed!"
echo ""
echo "To delete the entire KIND cluster:"
echo "   kind delete cluster --name student-app"
echo ""
echo "To recreate cluster:"
echo "   ./scripts/kind-setup.sh"

=== FILE: ./scripts/deploy-simple.sh ===
#!/bin/bash
set -e

echo "üöÄ SIMPLE Deploy - Student Management App"
echo "========================================="

# Clean up
echo "üßπ Cleaning up..."
kubectl delete -f k8s/ --ignore-not-found=true 2>/dev/null || true
kubectl delete namespace student-app --ignore-not-found=true 2>/dev/null || true
pkill -f "kubectl port-forward" 2>/dev/null || true

# Wait
sleep 3

# Create namespace
echo "üìÅ Creating namespace..."
kubectl create namespace student-app

# Apply configmap
echo "‚öôÔ∏è Creating configmap..."
cat > k8s/configmap-simple.yaml << 'EOF'
apiVersion: v1
kind: ConfigMap
metadata:
  name: backend-config
  namespace: student-app
data:
  NODE_ENV: "production"
  PORT: "3000"
EOF
kubectl apply -f k8s/configmap-simple.yaml

# Deploy simple backend
echo "üîß Deploying Backend (Simple)..."
cat > k8s/backend/deployment-simple.yaml << 'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: student-backend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
        env:
        - name: PORT
          value: "3000"
        - name: NODE_ENV
          value: "production"
        livenessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 5
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
EOF
kubectl apply -f k8s/backend/deployment-simple.yaml

# Deploy backend service
echo "üîå Deploying Backend Service..."
cat > k8s/backend/service-simple.yaml << 'EOF'
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: student-app
spec:
  selector:
    app: backend
  ports:
  - port: 3000
    targetPort: 3000
    nodePort: 30001
  type: NodePort
EOF
kubectl apply -f k8s/backend/service-simple.yaml

# Deploy frontend
echo "üé® Deploying Frontend..."
kubectl apply -f k8s/frontend/deployment.yaml
kubectl apply -f k8s/frontend/service.yaml

# Wait
echo "‚è≥ Waiting for pods..."
sleep 30

# Check status
echo "üìä Status:"
kubectl get all -n student-app

echo ""
echo "‚úÖ Simple deployment completed!"
echo "üåê Run: kubectl port-forward -n student-app service/backend-service 30001:3000 &"
echo "üåê Run: kubectl port-forward -n student-app service/frontend-service 8888:80 &"
echo "üåê Then open: http://localhost:8888"

=== FILE: ./scripts/deploy.sh ===
#!/bin/bash
set -e

echo "üöÄ Deploying Student Management App to KIND Kubernetes..."
echo "========================================================"

# Check if KIND cluster exists
if ! kind get clusters | grep -q "student-app"; then
    echo "‚ùå KIND cluster 'student-app' not found!"
    echo "   Run: ./scripts/kind-setup.sh"
    exit 1
fi

# Set kubectl context
kubectl config use-context kind-student-app

echo "üì¶ Building Docker images locally..."

# Build backend image
echo "üî® Building backend image..."
cd app/backend
docker build -t student-backend:latest .
cd ../..

# Build frontend image
echo "üé® Building frontend image..."
cd app/frontend
docker build -t student-frontend:latest .
cd ../..

echo "üì§ Loading images into KIND cluster..."
# Load images into KIND cluster
kind load docker-image student-backend:latest --name student-app
kind load docker-image student-frontend:latest --name student-app

echo "‚úÖ Images loaded into KIND cluster"

echo "üìÅ Creating namespace..."
kubectl apply -f k8s/namespace.yaml

echo "üîê Creating secrets..."
kubectl apply -f k8s/secrets.yaml

echo "‚öôÔ∏è Creating configmaps..."
kubectl apply -f k8s/configmap.yaml

# Deploy MySQL
echo "üóÑÔ∏è Deploying MySQL..."
kubectl apply -f k8s/mysql/

# Wait for MySQL to be ready
echo "‚è≥ Waiting for MySQL to be ready..."
kubectl wait --for=condition=ready pod -l app=mysql -n student-app --timeout=180s 2>/dev/null || echo "MySQL might still be starting..."

# Deploy Backend
echo "üîß Deploying Backend..."
kubectl apply -f k8s/backend/

# Deploy Frontend
echo "üé® Deploying Frontend..."
kubectl apply -f k8s/frontend/

# Wait for services to be ready
echo "‚è≥ Waiting for services to be ready..."
sleep 30

# Display deployment status
echo "üìä Deployment Status:"
kubectl get all -n student-app

echo ""
echo "‚úÖ Deployment completed!"
echo ""
echo "üåê Access URLs:"
echo "   Frontend:      http://localhost:31349"
echo "   Backend API:   http://localhost:30001/api/health"
echo "   Backend Students: http://localhost:30001/api/students"
echo ""
echo "üîß For detailed access:"
echo "   ./scripts/access-app.sh"
echo ""
echo "üìà To monitor:"
echo "   kubectl get pods -n student-app -w"

=== FILE: ./scripts/fix-everything.sh ===
#!/bin/bash
echo "üîß Fixing Everything - Student Management System"
echo "================================================"

# Stop everything
echo "üõë Stopping everything..."
pkill -f "kubectl port-forward" 2>/dev/null || true

# Delete current deployment
echo "üóëÔ∏è  Deleting current deployment..."
kubectl delete -f k8s/ --ignore-not-found=true
kubectl delete namespace student-app --ignore-not-found=true
sleep 5

# Rebuild images
echo "üî® Rebuilding Docker images..."
cd app/backend
docker build -t student-backend:latest .
cd ../frontend
docker build -t student-frontend:latest .
cd ../..

# Create fresh deployment
echo "üöÄ Creating fresh deployment..."

# Create namespace
kubectl create namespace student-app

# Apply in correct order
kubectl apply -f k8s/namespace.yaml
kubectl apply -f k8s/secrets.yaml
kubectl apply -f k8s/configmap.yaml

# Wait a bit
sleep 2

# Deploy MySQL first
echo "üóÑÔ∏è Deploying MySQL..."
kubectl apply -f k8s/mysql/

# Wait for MySQL
echo "‚è≥ Waiting for MySQL..."
sleep 30

# Deploy Backend with MySQL disabled (will use in-memory)
echo "üîß Deploying Backend (with in-memory storage)..."
kubectl apply -f k8s/backend/

# Wait for backend
echo "‚è≥ Waiting for Backend..."
sleep 20

# Deploy Frontend
echo "üé® Deploying Frontend..."
kubectl apply -f k8s/frontend/

# Wait for everything
echo "‚è≥ Waiting for all pods..."
sleep 30

# Check status
echo "üìä Deployment Status:"
kubectl get all -n student-app

echo ""
echo "üîç Checking pod status..."
kubectl get pods -n student-app

echo ""
echo "üìù Pod details:"
kubectl describe pods -n student-app

echo ""
echo "‚úÖ Fix completed!"
echo ""
echo "üåê To access the application:"
echo "1. Run: kubectl port-forward -n student-app service/backend-service 30001:3000 &"
echo "2. Run: kubectl port-forward -n student-app service/frontend-service 8888:80 &"
echo "3. Open: http://localhost:8888"
echo ""
echo "üêõ If issues persist, check logs:"
echo "   kubectl logs -n student-app deployment/backend"
echo "   kubectl logs -n student-app deployment/frontend"

=== FILE: ./scripts/destroy-jenkins.sh ===
#!/bin/bash
echo "üßπ Cleaning up Jenkins..."

kubectl delete -f jenkins/ --ignore-not-found=true
kubectl delete namespace jenkins --ignore-not-found=true

echo "‚úÖ Jenkins cleanup completed!"

=== FILE: ./scripts/reset-all.sh ===
#!/bin/bash
echo "üîÑ Complete Reset - Student Management App with KIND"
echo "==================================================="

echo "1. Cleaning up..."
./scripts/teardown.sh

echo "2. Deleting KIND cluster..."
kind delete cluster --name student-app 2>/dev/null || true

echo "3. Recreating KIND cluster..."
./scripts/kind-setup.sh

echo "4. Rebuilding and deploying..."
./scripts/deploy.sh

echo "5. Waiting for services..."
sleep 40

echo "6. Testing..."
curl -s http://localhost:30001/api/health || echo "Backend not ready yet"
curl -s http://localhost:31349 | head -5 || echo "Frontend not ready yet"

echo ""
echo "‚úÖ Reset completed!"
echo "üåê Access:"
echo "   Frontend: http://localhost:31349"
echo "   Backend:  http://localhost:30001/api/health"

=== FILE: ./scripts/redeploy-all.sh ===
#!/bin/bash
echo "üîÑ Complete Redeployment"
echo "======================="

# Clean up
echo "1. Cleaning up..."
pkill -f "kubectl port-forward" 2>/dev/null || true
./scripts/teardown.sh

# Recreate KIND cluster if needed
if ! kind get clusters | grep -q "student-app"; then
    echo "2. Creating KIND cluster..."
    kind create cluster --name student-app --config kind/kind-config-fixed.yaml
else
    echo "2. KIND cluster exists, skipping creation"
fi

# Set context
kubectl config use-context kind-student-app

# Rebuild and load images
echo "3. Rebuilding images..."
cd app/backend
docker build -t student-backend:latest .
cd ../frontend
docker build -t student-frontend:latest .
cd ../..

echo "4. Loading images to KIND..."
kind load docker-image student-backend:latest --name student-app
kind load docker-image student-frontend:latest --name student-app

# Deploy
echo "5. Deploying..."
kubectl apply -f k8s/namespace.yaml
kubectl apply -f k8s/secrets.yaml
kubectl apply -f k8s/configmap.yaml

# Skip MySQL (use in-memory)
echo "6. Deploying backend and frontend..."
kubectl apply -f k8s/backend/deployment.yaml
kubectl apply -f k8s/backend/service.yaml
kubectl apply -f k8s/frontend/deployment.yaml
kubectl apply -f k8s/frontend/service.yaml

# Wait
echo "7. Waiting for pods..."
sleep 40

# Check
echo "8. Checking deployment..."
kubectl get all -n student-app

# Test with port-forward
echo "9. Testing with port-forward..."
kubectl port-forward -n student-app service/backend-service 30001:3000 &
sleep 3
kubectl port-forward -n student-app service/frontend-service 8888:80 &
sleep 3

echo "10. Testing connections..."
curl -s http://localhost:30001/api/health && echo " - Backend OK" || echo " - Backend failed"
curl -s http://localhost:8888 | head -5 && echo " - Frontend OK" || echo " - Frontend failed"

echo ""
echo "‚úÖ Redeployment complete!"
echo "üåê Access via:"
echo "   Frontend: http://localhost:8888"
echo "   Backend:  http://localhost:30001/api/health"
echo ""
echo "üìù To stop port-forwarding: pkill -f 'kubectl port-forward'"


=== FILE: ./scripts/test-connection.sh ===
#!/bin/bash
echo "üîç Testing Kubernetes Connections..."
echo "==================================="

echo "1. Checking pods..."
kubectl get pods -n student-app

echo ""
echo "2. Checking services..."
kubectl get services -n student-app

echo ""
echo "3. Testing backend internally..."
kubectl exec -n student-app deployment/backend -- curl -s http://localhost:3000/api/health || echo "Backend internal check failed"

echo ""
echo "4. Testing backend via service..."
kubectl run -n student-app test-curl --image=curlimages/curl --rm -it --restart=Never -- curl -s http://backend-service:3000/api/health || echo "Service check failed"

echo ""
echo "5. Testing frontend-backend connection..."
kubectl exec -n student-app deployment/frontend -- curl -s http://backend-service:3000/api/health || echo "Frontend to backend check failed"

echo ""
echo "‚úÖ Tests completed!"

=== FILE: ./scripts/access-app-portforward.sh ===
#!/bin/bash
echo "üéì Student Management App - Port Forward Access"
echo "================================================"

# Kill existing port-forwards
pkill -f "kubectl port-forward" 2>/dev/null || true

echo "üöÄ Starting port forwarding..."

# Start backend port forward
echo "üîß Forwarding backend to port 30001..."
kubectl port-forward -n student-app service/backend-service 30001:3000 > /dev/null 2>&1 &
BACKEND_PID=$!

# Start frontend port forward
echo "üé® Forwarding frontend to port 8888..."
kubectl port-forward -n student-app service/frontend-service 8888:80 > /dev/null 2>&1 &
FRONTEND_PID=$!

# Wait for port forwarding to establish
sleep 5

echo ""
echo "üß™ Testing connections..."
echo "Backend API:"
curl -s http://localhost:30001/api/health | python3 -m json.tool 2>/dev/null || curl -s http://localhost:30001/api/health || echo "Backend not ready yet"

echo ""
echo "Frontend:"
curl -s -I http://localhost:8888 | head -1 || echo "Frontend not ready yet"

echo ""
echo "‚úÖ Application is now running via port-forward!"
echo ""
echo "üåê ACCESS URLs:"
echo "   Frontend (UI):    http://localhost:8888"
echo "   Backend (API):    http://localhost:30001/api"
echo ""
echo "üîç TEST ENDPOINTS:"
echo "   Health Check:     curl http://localhost:30001/api/health"
echo "   List Students:    curl http://localhost:30001/api/students"
echo ""
echo "‚èπÔ∏è  To stop: Press Ctrl+C"
echo ""
echo "üìù Note: This uses kubectl port-forward instead of KIND port mapping"
echo "   For direct KIND ports, check if ports 30001 and 31349 are open"

# Keep script running and handle cleanup
trap "echo 'Stopping port forwarding...'; kill $BACKEND_PID $FRONTEND_PID 2>/dev/null; exit 0" INT TERM

echo "Press Ctrl+C to stop..."
wait


=== FILE: ./backend-deploy.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: student-backend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: student-app
spec:
  type: NodePort
  selector:
    app: backend
  ports:
  - port: 3000
    targetPort: 3000
    nodePort: 30001


=== FILE: ./Jenkinsfile ===
pipeline {
    agent {
        kubernetes {
            label 'jenkins-agent'
            yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: docker
    image: docker:latest
    command: ['cat']
    tty: true
    volumeMounts:
    - name: docker-sock
      mountPath: /var/run/docker.sock
  - name: kubectl
    image: bitnami/kubectl:latest
    command: ['cat']
    tty: true
  volumes:
  - name: docker-sock
    hostPath:
      path: /var/run/docker.sock
"""
        }
    }
    
    environment {
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_USERNAME = credentials('docker-hub')
        DOCKER_PASSWORD = credentials('docker-hub')
        APP_NAME = 'student-app'
        KUBE_NAMESPACE = 'student-app'
        GIT_COMMIT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Build Docker Images') {
            steps {
                container('docker') {
                    script {
                        // Build Backend
                        sh """
                            docker build -t ${DOCKER_USERNAME}/student-backend:${GIT_COMMIT} app/backend/
                            docker tag ${DOCKER_USERNAME}/student-backend:${GIT_COMMIT} ${DOCKER_USERNAME}/student-backend:latest
                        """
                        
                        // Build Frontend
                        sh """
                            docker build -t ${DOCKER_USERNAME}/student-frontend:${GIT_COMMIT} app/frontend/
                            docker tag ${DOCKER_USERNAME}/student-frontend:${GIT_COMMIT} ${DOCKER_USERNAME}/student-frontend:latest
                        """
                    }
                }
            }
        }
        
        stage('Push to Docker Hub') {
            steps {
                container('docker') {
                    script {
                        sh """
                            echo "${DOCKER_PASSWORD}" | docker login -u "${DOCKER_USERNAME}" --password-stdin
                            docker push ${DOCKER_USERNAME}/student-backend:${GIT_COMMIT}
                            docker push ${DOCKER_USERNAME}/student-backend:latest
                            docker push ${DOCKER_USERNAME}/student-frontend:${GIT_COMMIT}
                            docker push ${DOCKER_USERNAME}/student-frontend:latest
                        """
                    }
                }
            }
        }
        
        stage('Deploy to K8s') {
            steps {
                container('kubectl') {
                    script {
                        // Update deployment images
                        sh """
                            kubectl set image deployment/backend backend=${DOCKER_USERNAME}/student-backend:${GIT_COMMIT} -n ${KUBE_NAMESPACE}
                            kubectl set image deployment/frontend frontend=${DOCKER_USERNAME}/student-frontend:${GIT_COMMIT} -n ${KUBE_NAMESPACE}
                        """
                        
                        // Wait for rollout
                        sh """
                            kubectl rollout status deployment/backend -n ${KUBE_NAMESPACE} --timeout=300s
                            kubectl rollout status deployment/frontend -n ${KUBE_NAMESPACE} --timeout=300s
                        """
                    }
                }
            }
        }
        
        stage('Verify Deployment') {
            steps {
                container('kubectl') {
                    sh '''
                        echo "Verifying deployment..."
                        kubectl get pods -n student-app
                        curl -f http://localhost:30001/api/health || echo "Health check will pass after port-forward"
                    '''
                }
            }
        }
    }
    
    post {
        success {
            echo '‚úÖ Pipeline completed successfully!'
        }
        failure {
            echo '‚ùå Pipeline failed!'
        }
    }
}

=== FILE: ./get-data-working.sh ===
#!/bin/bash
echo "üéØ GET DATA WORKING - Complete Solution"
echo "======================================"

# Stop everything
pkill -f "kubectl port-forward" 2>/dev/null || true

# Delete everything
kubectl delete namespace student-app --ignore-not-found=true
sleep 3

# Create namespace
kubectl create namespace student-app

# Build fresh images
echo "1. Building fresh Docker images..."
cd ~/student-app-k8s-jenkins-cicd

# Create ultra-simple backend
cd app/backend
cat > app-guaranteed.js << 'APP'
console.log("üöÄ GUARANTEED BACKEND STARTING");
const express = require("express");
const cors = require("cors");
const app = express();
app.use(cors());
app.use(express.json());

const students = [
    {id:1,name:"GUARANTEED Student 1",age:20,grade:"A",email:"student1@school.com"},
    {id:2,name:"GUARANTEED Student 2",age:21,grade:"B",email:"student2@school.com"},
    {id:3,name:"GUARANTEED Student 3",age:22,grade:"A",email:"student3@school.com"},
    {id:4,name:"GUARANTEED Student 4",age:23,grade:"C",email:"student4@school.com"},
    {id:5,name:"GUARANTEED Student 5",age:19,grade:"B",email:"student5@school.com"}
];

app.get("/api/health", (req, res) => {
    console.log("Health check");
    res.json({status:"OK",message:"GUARANTEED Backend",students:students.length});
});

app.get("/api/students", (req, res) => {
    console.log("Returning", students.length, "students");
    res.json(students);
});

app.listen(3000, "0.0.0.0", () => {
    console.log("‚úÖ GUARANTEED Backend running on 3000");
});
APP

# Replace app.js
cp app-guaranteed.js app.js

# Ensure package.json exists
cat > package.json << 'PKG'
{
  "name": "student-backend",
  "version": "1.0.0",
  "main": "app.js",
  "scripts": {
    "start": "node app.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5"
  }
}
PKG

# Build image
docker build -t student-backend:latest .
cd ../..

echo "2. Building frontend..."
cd app/frontend

# Create simple frontend
cat > index-guaranteed.html << 'HTML'
<!DOCTYPE html>
<html>
<head>
    <title>Student Management - GUARANTEED</title>
    <style>
        body { font-family: Arial; padding: 20px; }
        h1 { color: #333; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
        th { background: #4CAF50; color: white; }
        .status { padding: 10px; margin: 10px 0; border-radius: 5px; }
        .online { background: #4CAF50; color: white; }
        .offline { background: #f44336; color: white; }
    </style>
</head>
<body>
    <h1>üéì Student Management System</h1>
    <div id="status" class="status">Loading...</div>
    
    <table>
        <thead>
            <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Age</th>
                <th>Grade</th>
                <th>Email</th>
            </tr>
        </thead>
        <tbody id="students-table">
            <tr><td colspan="5">Loading data...</td></tr>
        </tbody>
    </table>
    
    <script>
        const API_URL = 'http://localhost:30001/api';
        
        async function loadData() {
            try {
                // Try API first
                const response = await fetch(API_URL + '/students');
                if (response.ok) {
                    const students = await response.json();
                    displayStudents(students);
                    document.getElementById('status').className = 'status online';
                    document.getElementById('status').textContent = `‚úÖ Loaded ${students.length} students from API`;
                    return;
                }
            } catch (error) {
                console.log('API error:', error);
            }
            
            // Fallback
            const demo = [
                {id:1,name:'FALLBACK Student',age:20,grade:'A',email:'fallback@school.com'}
            ];
            displayStudents(demo);
            document.getElementById('status').className = 'status offline';
            document.getElementById('status').textContent = '‚ö†Ô∏è Using fallback data';
        }
        
        function displayStudents(students) {
            const table = document.getElementById('students-table');
            table.innerHTML = students.map(s => `
                <tr>
                    <td>${s.id}</td>
                    <td>${s.name}</td>
                    <td>${s.age}</td>
                    <td>${s.grade}</td>
                    <td>${s.email}</td>
                </tr>
            `).join('');
        }
        
        // Load on page load
        loadData();
    </script>
</body>
</html>
HTML

# Replace index.html
cp index-guaranteed.html index.html

# Create app.js
cat > app.js << 'JS'
console.log("GUARANTEED Frontend loaded");
JS

docker build -t student-frontend:latest .
cd ../..

echo "3. Loading images to KIND..."
kind load docker-image student-backend:latest --name student-app
kind load docker-image student-frontend:latest --name student-app

echo "4. Deploying to Kubernetes..."
cat > guaranteed-deploy.yaml << 'DEPLOY'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: student-backend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: student-app
spec:
  type: NodePort
  selector:
    app: backend
  ports:
  - port: 3000
    targetPort: 3000
    nodePort: 30001
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: student-frontend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: student-app
spec:
  type: NodePort
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
    nodePort: 31349
DEPLOY

kubectl apply -f guaranteed-deploy.yaml

echo "5. Waiting for pods (40 seconds)..."
sleep 40

echo "6. Checking deployment..."
kubectl get all -n student-app

echo "7. Setting up port forwarding..."
kubectl port-forward -n student-app service/backend-service 30001:3000 > /dev/null 2>&1 &
sleep 3
kubectl port-forward -n student-app service/frontend-service 8888:80 > /dev/null 2>&1 &
sleep 3

echo "8. Testing..."
echo "Backend test:"
curl -s http://localhost:30001/api/health && echo " - ‚úÖ Backend OK" || echo " - ‚ùå Backend failed"

echo ""
echo "Frontend test:"
curl -s http://localhost:8888 | grep -o "<title>.*</title>" && echo " - ‚úÖ Frontend OK" || echo " - ‚ùå Frontend failed"

echo ""
echo "üéâ GUARANTEED SETUP COMPLETE!"
echo "üåê Open browser to: http://localhost:8888"
echo ""
echo "üìù Data WILL show because:"
echo "   1. Backend has guaranteed data"
echo "   2. Frontend connects to localhost:30001"
echo "   3. No MySQL dependencies"
echo ""
echo "üîÑ If still no data:"
echo "   - Hard refresh: Ctrl+Shift+R"
echo "   - Check browser console: F12 ‚Üí Console"
echo "   - Test API directly: curl http://localhost:30001/api/students"


=== FILE: ./simple-frontend.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: student-frontend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: student-app
spec:
  type: NodePort
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
    nodePort: 31349


=== FILE: ./frontend-deploy.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: student-frontend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: student-app
spec:
  type: NodePort
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
    nodePort: 31349


=== FILE: ./update-frontend.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: student-frontend-original:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 80


=== FILE: ./docker-hub-secret.yaml ===
apiVersion: v1
kind: Secret
metadata:
  name: docker-hub-secret
  namespace: student-app
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: ewoJImF1dGhzIjogewoJCSJodHRwczovL2luZGV4LmRvY2tlci5pby92MS8iOiB7CgkJCSJhdXRoIjogIllXUnRhVzQ2VjIxMVUxVjRVVDA9IgoJCX0KCX0KfQ==  # Replace with your base64 encoded docker config

=== FILE: ./test-connection.sh ===
#!/bin/bash
echo "üîç Testing Frontend-Backend Connection"
echo "======================================"

echo "1. Testing backend directly..."
curl -s http://localhost:30001/api/health && echo "‚úÖ Backend health OK" || echo "‚ùå Backend health failed"
curl -s http://localhost:30001/api/students | jq '. | length' 2>/dev/null || curl -s http://localhost:30001/api/students | head -c 100

echo ""
echo "2. Checking pods..."
kubectl get pods -n student-app -o wide

echo ""
echo "3. Checking services..."
kubectl get svc -n student-app

echo ""
echo "4. Checking backend logs..."
kubectl logs -n student-app deployment/backend --tail=5

echo ""
echo "5. Checking frontend logs..."
kubectl logs -n student-app deployment/frontend --tail=5

echo ""
echo "6. Testing from frontend pod..."
FRONTEND_POD=$(kubectl get pods -n student-app -l app=frontend -o jsonpath='{.items[0].metadata.name}')
echo "Frontend pod: $FRONTEND_POD"
kubectl exec -n student-app $FRONTEND_POD -- curl -s http://backend-service:3000/api/health || echo "Frontend cannot reach backend"

echo ""
echo "7. Browser test instructions:"
echo "   Open: http://localhost:8888"
echo "   Press F12 to open Developer Tools"
echo "   Go to Console tab"
echo "   Look for errors or API_BASE_URL log"


=== FILE: ./update-backend-crud.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: student-backend-crud:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000


=== FILE: ./fix-backend-now.sh ===
#!/bin/bash
echo "üõ†Ô∏è Fixing Backend Now!"
echo "======================"

cd ~/student-app-k8s-jenkins-cicd

# Kill port-forwards
pkill -f "kubectl port-forward" 2>/dev/null || true

# Delete old backend
kubectl delete deployment backend -n student-app --ignore-not-found=true

# Create fixed backend
mkdir -p /tmp/fixed-backend
cd /tmp/fixed-backend

echo "Creating fixed backend..."
cat > index.js << 'EOL'
const express = require('express');
const cors = require('cors');
const app = express();
app.use(cors());
app.use(express.json());

const students = [
    {id:1,name:"Fixed Student 1",age:20,grade:"A",email:"fixed1@school.com"},
    {id:2,name:"Fixed Student 2",age:21,grade:"B",email:"fixed2@school.com"},
    {id:3,name:"Fixed Student 3",age:22,grade:"A",email:"fixed3@school.com"}
];

app.get('/api/health', (req,res) => {
    res.json({status:"FIXED",message:"This backend works!"});
});

app.get('/api/students', (req,res) => {
    res.json(students);
});

app.listen(3000, '0.0.0.0', () => console.log('‚úÖ Fixed backend on 3000'));
EOL

cat > package.json << 'EOL'
{
  "name": "fixed-backend",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5"
  }
}
EOL

cat > Dockerfile << 'EOL'
FROM node:18-alpine
WORKDIR /app
COPY package.json ./
RUN npm install
COPY index.js .
EXPOSE 3000
CMD ["node", "index.js"]
EOL

# Build
docker build -t fixed-backend:latest .

# Deploy
cd ~/student-app-k8s-jenkins-cicd
cat > fixed-deploy.yaml << 'EOL'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: fixed-backend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
EOL

kubectl apply -f fixed-deploy.yaml
kubectl apply -f k8s/backend/service.yaml

echo "Waiting 20 seconds..."
sleep 20

echo "Checking status..."
kubectl get pods -n student-app

echo "Testing..."
kubectl port-forward -n student-app service/backend-service 30001:3000 &
sleep 3
curl -s http://localhost:30001/api/health | head -c 100
echo ""
curl -s http://localhost:30001/api/students | head -c 100
echo ""

echo "Starting frontend..."
kubectl port-forward -n student-app service/frontend-service 8888:80 &
echo "‚úÖ Open: http://localhost:8888"


=== FILE: ./update-ui.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: student-frontend-original:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 80


=== FILE: ./kind/load-images.sh ===
#!/bin/bash
echo "üì§ Loading Docker images into KIND cluster..."

if ! kind get clusters | grep -q "student-app"; then
    echo "‚ùå KIND cluster 'student-app' not found!"
    exit 1
fi

# Load backend image
if docker images | grep -q "student-backend"; then
    echo "üì¶ Loading student-backend:latest..."
    kind load docker-image student-backend:latest --name student-app
else
    echo "‚ö†Ô∏è  student-backend:latest not found locally"
fi

# Load frontend image
if docker images | grep -q "student-frontend"; then
    echo "üé® Loading student-frontend:latest..."
    kind load docker-image student-frontend:latest --name student-app
else
    echo "‚ö†Ô∏è  student-frontend:latest not found locally"
fi

echo "‚úÖ Images loaded into KIND cluster"

=== FILE: ./kind/registry.yaml ===
apiVersion: v1
kind: ConfigMap
metadata:
  name: local-registry-hosting
  namespace: kube-public
data:
  localRegistryHosting.v1: |
    host: "localhost:5000"
    help: "https://kind.sigs.k8s.io/docs/user/local-registry/"

=== FILE: ./kind/kind-config-fixed.yaml ===
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  extraPortMappings:
  - containerPort: 30001
    hostPort: 30001
    listenAddress: "0.0.0.0"
    protocol: tcp
  - containerPort: 31349
    hostPort: 31349
    listenAddress: "0.0.0.0"
    protocol: tcp
  - containerPort: 32000
    hostPort: 32000
    listenAddress: "0.0.0.0"
    protocol: tcp


=== FILE: ./kind/kind-setup.sh ===
#!/bin/bash
echo "üöÄ Setting up KIND (Kubernetes in Docker)"
echo "========================================="

# Install KIND if not installed
if ! command -v kind &> /dev/null; then
    echo "üì¶ Installing KIND..."
    curl -Lo ./kind https://kind.sigs.k8s.io/dl/latest/kind-linux-amd64
    chmod +x ./kind
    sudo mv ./kind /usr/local/bin/kind
    echo "‚úÖ KIND installed"
else
    echo "‚úÖ KIND already installed"
fi

# Install kubectl if not installed
if ! command -v kubectl &> /dev/null; then
    echo "üì¶ Installing kubectl..."
    curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    chmod +x kubectl
    sudo mv kubectl /usr/local/bin/kubectl
    echo "‚úÖ kubectl installed"
else
    echo "‚úÖ kubectl already installed"
fi

# Create KIND cluster configuration
echo "üìù Creating KIND cluster configuration..."
cat > kind/kind-config.yaml << 'EOF'
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  kubeadmConfigPatches:
  - |
    kind: InitConfiguration
    nodeRegistration:
      kubeletExtraArgs:
        node-labels: "ingress-ready=true"
  extraPortMappings:
  - containerPort: 80
    hostPort: 80
    protocol: TCP
  - containerPort: 443
    hostPort: 443
    protocol: TCP
  - containerPort: 30001
    hostPort: 30001
    protocol: TCP
  - containerPort: 31349
    hostPort: 31349
    protocol: TCP
  - containerPort: 32000
    hostPort: 32000
    protocol: TCP
- role: worker
- role: worker
EOF

# Create or start KIND cluster
if kind get clusters | grep -q "student-app"; then
    echo "üîÑ KIND cluster 'student-app' already exists"
    echo "   To delete and recreate: kind delete cluster --name student-app"
else
    echo "üöÄ Creating KIND cluster 'student-app'..."
    kind create cluster --name student-app --config kind/kind-config.yaml
fi

# Set kubectl context
kubectl config use-context kind-student-app

# Check cluster status
echo "üìä Cluster status:"
kubectl cluster-info
kubectl get nodes

echo ""
echo "‚úÖ KIND setup completed!"
echo "üåê Cluster: student-app"
echo "üë§ Context: kind-student-app"

=== FILE: ./fixed-deploy.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: fixed-backend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000


=== FILE: ./k8s/frontend/configmap.yaml ===
apiVersion: v1
kind: ConfigMap
metadata:
  name: frontend-config
  namespace: student-app
data:
  api-base-url: "http://backend-service:3000"
  app-title: "Student Management System - Kubernetes"

=== FILE: ./k8s/frontend/service-nodeport.yaml ===
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: student-app
spec:
  type: NodePort
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
    nodePort: 31349


=== FILE: ./k8s/frontend/service.yaml ===
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: student-app
spec:
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
    nodePort: 31349  # Keep existing node port for Minikube access
  type: LoadBalancer


=== FILE: ./k8s/frontend/hpa.yaml ===
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: frontend-hpa
  namespace: student-app
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: frontend
  minReplicas: 2
  maxReplicas: 5
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 60

=== FILE: ./k8s/frontend/deployment.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: student-frontend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 80
        env:
        - name: API_BASE_URL
          value: "http://backend-service:3000"  # This is for Kubernetes
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 15
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"

=== FILE: ./k8s/backend/service-fixed.yaml ===
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: student-app
spec:
  selector:
    app: backend
  ports:
  - port: 3000
    targetPort: 3000
    nodePort: 30001
  type: NodePort


=== FILE: ./k8s/backend/deployment-memory.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: student-backend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
        env:
        - name: USE_MYSQL
          value: "false"
        - name: PORT
          value: "3000"
        livenessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5


=== FILE: ./k8s/backend/deployment-minikube.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: minikube-backend:latest
        imagePullPolicy: Never  # Important: Don't pull from registry
        ports:
        - containerPort: 3000


=== FILE: ./k8s/backend/service-simple.yaml ===
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: student-app
spec:
  selector:
    app: backend
  ports:
  - port: 3000
    targetPort: 3000
    nodePort: 30001
  type: NodePort


=== FILE: ./k8s/backend/deployment-simple.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: student-backend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
        env:
        - name: PORT
          value: "3000"
        - name: NODE_ENV
          value: "production"


=== FILE: ./k8s/backend/service-nodeport.yaml ===
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: student-app
spec:
  type: NodePort
  selector:
    app: backend
  ports:
  - port: 3000
    targetPort: 3000
    nodePort: 30001


=== FILE: ./k8s/backend/service.yaml ===
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: student-app
spec:
  selector:
    app: backend
  ports:
  - port: 3000
    targetPort: 3000
    nodePort: 30001  # Fixed node port for consistency
  type: NodePort


=== FILE: ./k8s/backend/deployment-fixed.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: student-backend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
        env:
        - name: PORT
          value: "3000"


=== FILE: ./k8s/backend/hpa.yaml ===
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: backend-hpa
  namespace: student-app
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: backend
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 50
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 70

=== FILE: ./k8s/backend/deployment-fresh.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: student-backend-fresh:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
        env:
        - name: PORT
          value: "3000"
        # Remove health checks temporarily
        # livenessProbe:
        #   httpGet:
        #     path: /api/health
        #     port: 3000
        #   initialDelaySeconds: 30
        #   periodSeconds: 10
        # readinessProbe:
        #   httpGet:
        #     path: /api/health
        #     port: 3000
        #   initialDelaySeconds: 10
        #   periodSeconds: 5
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"


=== FILE: ./k8s/backend/deployment.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: student-backend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
        env:
        - name: MYSQL_HOST
          value: "mysql-service"
        - name: MYSQL_USER
          value: "student_user"
        - name: MYSQL_PASSWORD
          value: "student_pass"
        - name: MYSQL_DATABASE
          value: "student_db"
        - name: PORT
          value: "3000"
        - name: USE_MYSQL  # Add this to use in-memory if MySQL fails
          value: "false"
        # Add startup probe to wait for backend to be ready
        startupProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 5
          failureThreshold: 30
        livenessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"

=== FILE: ./k8s/configmap.yaml ===
apiVersion: v1
kind: ConfigMap
metadata:
  name: backend-config
  namespace: student-app
data:
  DB_NAME: "student_db"
  NODE_ENV: "production"
  PORT: "3000"

=== FILE: ./k8s/configmap-simple.yaml ===
apiVersion: v1
kind: ConfigMap
metadata:
  name: backend-config
  namespace: student-app
data:
  NODE_ENV: "production"
  PORT: "3000"


=== FILE: ./k8s/secrets.yaml ===
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secrets  # Changed from mysql-secret
  namespace: student-app
type: Opaque
data:
  mysql-root-password: cm9vdHBhc3N3b3Jk  # "rootpassword" base64 encoded
  mysql-password: c3R1ZGVudF9wYXNz  # "student_pass" base64 encoded

=== FILE: ./k8s/namespace.yaml ===
apiVersion: v1
kind: Namespace
metadata:
  name: student-app
  labels:
    name: student-app
    env: development
    app: student-management

=== FILE: ./k8s/mysql/pvc.yaml ===
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: student-app
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi

=== FILE: ./k8s/mysql/service.yaml ===
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
  namespace: student-app
spec:
  selector:
    app: mysql
  ports:
  - port: 3306
    targetPort: 3306
  clusterIP: None

=== FILE: ./k8s/mysql/deployment.yaml ===
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: student-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secrets
              key: mysql-root-password
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secrets
              key: mysql-password
        - name: MYSQL_DATABASE
          value: "student_db"
        - name: MYSQL_USER
          value: "student_user"
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
        - name: mysql-initdb
          mountPath: /docker-entrypoint-initdb.d
        # Simpler health checks
        livenessProbe:
          tcpSocket:
            port: 3306
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - mysqladmin
            - ping
            - -h
            - localhost
            - -uroot
            - -prootpassword
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
      - name: mysql-initdb
        configMap:
          name: mysql-initdb-config

=== FILE: ./test-application.sh ===
#!/bin/bash
echo "üß™ Testing Student Management Application"
echo "========================================="

echo "1. Checking pods..."
kubectl get pods -n student-app

echo ""
echo "2. Testing Backend API..."
echo "Health Check:"
curl -s http://localhost:30001/api/health || echo "‚ùå Backend not accessible"

echo ""
echo "Students API:"
curl -s http://localhost:30001/api/students || echo "‚ùå Students endpoint not working"

echo ""
echo "3. Testing Frontend..."
echo "Frontend HTML (first 5 lines):"
curl -s http://localhost:31349 | head -5 || echo "‚ùå Frontend not accessible"

echo ""
echo "4. Checking logs..."
echo "Backend logs (last 5 lines):"
kubectl logs -n student-app deployment/backend --tail=5 2>/dev/null || echo "Cannot get logs"

echo ""
echo "‚úÖ Test completed!"
echo "üåê Open browser to: http://localhost:31349"


=== FILE: ./minikube-backend/server.js ===
const express = require('express');
const cors = require('cors');
const app = express();
const PORT = 3000;

console.log('üöÄ Minikube Backend Starting...');

app.use(cors());
app.use(express.json());

const students = [
    { id: 1, name: 'Minikube Student 1', age: 20, grade: 'A', email: 'student1@school.com' },
    { id: 2, name: 'Minikube Student 2', age: 21, grade: 'B', email: 'student2@school.com' },
    { id: 3, name: 'Minikube Student 3', age: 22, grade: 'A', email: 'student3@school.com' },
    { id: 4, name: 'Minikube Student 4', age: 23, grade: 'C', email: 'student4@school.com' },
    { id: 5, name: 'Minikube Student 5', age: 19, grade: 'B', email: 'student5@school.com' }
];

// Health endpoint
app.get('/api/health', (req, res) => {
    res.json({
        status: 'OK',
        message: 'Minikube Backend is running!',
        timestamp: new Date().toISOString(),
        studentCount: students.length
    });
});

// Get all students
app.get('/api/students', (req, res) => {
    console.log('Sending', students.length, 'students');
    res.json(students);
});

// Get student by ID
app.get('/api/students/:id', (req, res) => {
    const student = students.find(s => s.id === parseInt(req.params.id));
    if (student) {
        res.json(student);
    } else {
        res.status(404).json({ error: 'Student not found' });
    }
});

// Create student
app.post('/api/students', (req, res) => {
    const newStudent = {
        id: students.length + 1,
        ...req.body
    };
    students.push(newStudent);
    res.status(201).json(newStudent);
});

// Update student
app.put('/api/students/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const index = students.findIndex(s => s.id === id);
    if (index !== -1) {
        students[index] = { id, ...req.body };
        res.json(students[index]);
    } else {
        res.status(404).json({ error: 'Student not found' });
    }
});

// Delete student
app.delete('/api/students/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const index = students.findIndex(s => s.id === id);
    if (index !== -1) {
        students.splice(index, 1);
        res.json({ message: 'Student deleted' });
    } else {
        res.status(404).json({ error: 'Student not found' });
    }
});

app.listen(PORT, '0.0.0.0', () => {
    console.log(`‚úÖ Minikube Backend running on port ${PORT}`);
    console.log(`‚úÖ Health: http://localhost:${PORT}/api/health`);
    console.log(`‚úÖ Students: http://localhost:${PORT}/api/students`);
});


=== FILE: ./minikube-backend/Dockerfile ===
FROM node:18-alpine
WORKDIR /app
COPY package.json .
RUN npm install
COPY server.js .
EXPOSE 3000
CMD ["node", "server.js"]


